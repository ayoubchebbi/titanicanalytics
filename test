Voici comment gérer les `@wire` avec des **Promises** pour un contrôle plus fin :

## Solution 1 : Conversion @wire en Promise

```javascript
export default class ProductWorkOrderMatcher extends LightningElement {
    matchedData = [];
    isLoading = true;
    error = null;

    @wire(graphql, { query: productQuery })
    productItemsResult;

    @wire(graphql, { query: workOrderQuery })
    workOrderLineItemsResult;

    async connectedCallback() {
        try {
            await this.waitForWiredData();
            this.matchedData = this.performMatching();
        } catch (error) {
            this.error = error;
        } finally {
            this.isLoading = false;
        }
    }

    // Convertir @wire en Promise
    waitForWiredData() {
        return new Promise((resolve, reject) => {
            const checkData = () => {
                // Vérifier les erreurs
                if (this.productItemsResult?.error || this.workOrderLineItemsResult?.error) {
                    reject(this.productItemsResult?.error || this.workOrderLineItemsResult?.error);
                    return;
                }

                // Vérifier si les données sont prêtes
                if (this.productItemsResult?.data && this.workOrderLineItemsResult?.data) {
                    resolve({
                        products: this.productItemsResult.data,
                        workOrders: this.workOrderLineItemsResult.data
                    });
                    return;
                }

                // Réessayer après un délai
                setTimeout(checkData, 50);
            };

            checkData();
        });
    }
}
```

## Solution 2 : Promise.all avec gestion d'état

```javascript
export default class ProductWorkOrderMatcher extends LightningElement {
    matchedData = [];
    loadingState = {
        products: false,
        workOrders: false,
        matching: false
    };

    @wire(graphql, { query: productQuery })
    productItemsResult;

    @wire(graphql, { query: workOrderQuery })
    workOrderLineItemsResult;

    async connectedCallback() {
        try {
            // Attendre que toutes les données soient chargées
            const [productData, workOrderData] = await Promise.all([
                this.waitForProductData(),
                this.waitForWorkOrderData()
            ]);

            this.loadingState.matching = true;
            this.matchedData = await this.performMatchingAsync(productData, workOrderData);
            
        } catch (error) {
            this.handleError(error);
        } finally {
            this.resetLoadingState();
        }
    }

    waitForProductData() {
        return new Promise((resolve, reject) => {
            this.loadingState.products = true;
            
            const checkProductData = () => {
                if (this.productItemsResult?.error) {
                    reject(this.productItemsResult.error);
                    return;
                }
                
                if (this.productItemsResult?.data) {
                    this.loadingState.products = false;
                    resolve(this.extractNodes(this.productItemsResult.data.uiapi.query.ProductItem));
                    return;
                }
                
                setTimeout(checkProductData, 100);
            };
            
            checkProductData();
        });
    }

    waitForWorkOrderData() {
        return new Promise((resolve, reject) => {
            this.loadingState.workOrders = true;
            
            const checkWorkOrderData = () => {
                if (this.workOrderLineItemsResult?.error) {
                    reject(this.workOrderLineItemsResult.error);
                    return;
                }
                
                if (this.workOrderLineItemsResult?.data) {
                    this.loadingState.workOrders = false;
                    resolve(this.extractNodes(this.workOrderLineItemsResult.data.uiapi.query.WorkOrderLineItem));
                    return;
                }
                
                setTimeout(checkWorkOrderData, 100);
            };
            
            checkWorkOrderData();
        });
    }

    // Version asynchrone du matching pour gros volumes
    async performMatchingAsync(productItems, workOrderItems) {
        return new Promise((resolve) => {
            // Utiliser requestIdleCallback pour éviter de bloquer l'UI
            const performWork = (deadline) => {
                const result = this.optimizedMatcher(productItems, workOrderItems);
                resolve(result);
            };

            if (window.requestIdleCallback) {
                window.requestIdleCallback(performWork);
            } else {
                setTimeout(() => performWork(), 0);
            }
        });
    }
}
```

## Solution 3 : Approche avec async/await et timeout

```javascript
export default class ProductWorkOrderMatcher extends LightningElement {
    static TIMEOUT_DURATION = 10000; // 10 secondes
    
    async connectedCallback() {
        try {
            const data = await this.loadDataWithTimeout();
            this.processMatchedData(data);
        } catch (error) {
            this.handleError(error);
        }
    }

    async loadDataWithTimeout() {
        const timeoutPromise = new Promise((_, reject) => {
            setTimeout(() => reject(new Error('Timeout: Les données n\'ont pas été chargées')), 
                      ProductWorkOrderMatcher.TIMEOUT_DURATION);
        });

        const dataPromise = this.waitForAllData();

        // Race
