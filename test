
/**
 * @description Trigger Handler for Service Resource Shift overlap validation
 * @author Your Name
 * @date 2025
 */
public with sharing class ShiftTriggerHandler {
    
    // Constants for error messages
    private static final String OVERLAP_ERROR_MESSAGE = 'This Service Resource is already assigned to other ST ({0}) and overlaps with the shift time ({1})';
    private static final String DATETIME_FORMAT = 'yyyy-MM-dd HH:mm';
    
    /**
     * @description Main method to handle shift overlap validation before insert/update
     * @param newShifts List of new shift records
     * @param oldShifts Map of old shift records (null for insert)
     */
    public static void validateShiftOverlaps(List<Shift> newShifts, Map<Id, Shift> oldShifts) {
        try {
            // Filter shifts that need validation
            List<Shift> shiftsToValidate = filterShiftsForValidation(newShifts, oldShifts);
            
            if (shiftsToValidate.isEmpty()) {
                return;
            }
            
            // Get existing overlapping shifts
            Map<Id, List<Shift>> existingShiftsByResource = getExistingShifts(shiftsToValidate);
            
            // Validate each shift for overlaps
            for (Shift currentShift : shiftsToValidate) {
                validateSingleShiftOverlap(currentShift, existingShiftsByResource.get(currentShift.ServiceResourceId));
            }
            
        } catch (Exception e) {
            // Log error for debugging
            System.debug(LoggingLevel.ERROR, 'Error in shift overlap validation: ' + e.getMessage());
            throw new ShiftValidationException('Unable to validate shift overlaps: ' + e.getMessage());
        }
    }
    
    /**
     * @description Filter shifts that need overlap validation
     * @param newShifts List of new shift records
     * @param oldShifts Map of old shift records
     * @return List of shifts to validate
     */
    private static List<Shift> filterShiftsForValidation(List<Shift> newShifts, Map<Id, Shift> oldShifts) {
        List<Shift> shiftsToValidate = new List<Shift>();
        
        for (Shift shift : newShifts) {
            // Skip if missing required fields
            if (shift.ServiceResourceId == null || shift.StartTime == null || shift.EndTime == null) {
                continue;
            }
            
            // For updates, only validate if relevant fields changed
            if (oldShifts != null) {
                Shift oldShift = oldShifts.get(shift.Id);
                if (oldShift != null && !hasRelevantFieldsChanged(shift, oldShift)) {
                    continue;
                }
            }
            
            shiftsToValidate.add(shift);
        }
        
        return shiftsToValidate;
    }
    
    /**
     * @description Check if fields relevant to overlap validation have changed
     * @param newShift New shift record
     * @param oldShift Old shift record
     * @return Boolean indicating if relevant fields changed
     */
    private static Boolean hasRelevantFieldsChanged(Shift newShift, Shift oldShift) {
        return newShift.ServiceResourceId != oldShift.ServiceResourceId ||
               newShift.ServiceTerritoryId != oldShift.ServiceTerritoryId ||
               newShift.StartTime != oldShift.StartTime ||
               newShift.EndTime != oldShift.EndTime;
    }
    
    /**
     * @description Get existing shifts for the service resources
     * @param shiftsToValidate List of shifts to validate
     * @return Map of Service Resource Id to list of existing shifts
     */
    private static Map<Id, List<Shift>> getExistingShifts(List<Shift> shiftsToValidate) {
        // Collect Service Resource IDs
        Set<Id> serviceResourceIds = new Set<Id>();
        for (Shift shift : shiftsToValidate) {
            serviceResourceIds.add(shift.ServiceResourceId);
        }
        
        // Query existing shifts
        List<Shift> existingShifts = [
            SELECT Id, ServiceResourceId, ServiceTerritoryId, StartTime, EndTime,
                   ServiceTerritory.Name
            FROM Shift
            WHERE ServiceResourceId IN :serviceResourceIds
            AND StartTime != null
            AND EndTime != null
            ORDER BY ServiceResourceId, StartTime
        ];
        
        // Group by Service Resource
        Map<Id, List<Shift>> shiftsByResource = new Map<Id, List<Shift>>();
        for (Shift shift : existingShifts) {
            if (!shiftsByResource.containsKey(shift.ServiceResourceId)) {
                shiftsByResource.put(shift.ServiceResourceId, new List<Shift>());
            }
            shiftsByResource.get(shift.ServiceResourceId).add(shift);
        }
        
        return shiftsByResource;
    }
    
    /**
     * @description Validate a single shift for overlaps
     * @param currentShift Shift to validate
     * @param existingShifts List of existing shifts for the same Service Resource
     */
    private static void validateSingleShiftOverlap(Shift currentShift, List<Shift> existingShifts) {
        if (existingShifts == null || existingShifts.isEmpty()) {
            return;
        }
        
        for (Shift existingShift : existingShifts) {
            // Skip self-comparison for updates
            if (currentShift.Id == existingShift.Id) {
                continue;
            }
            
            // Check for time overlap
            if (hasTimeOverlap(currentShift, existingShift)) {
                // Check if same service territory (France-specific requirement check)
                if (isSameServiceTerritory(currentShift, existingShift)) {
                    addOverlapError(currentShift, existingShift);
                }
            }
        }
    }
    
    /**
     * @description Check if two shifts have time overlap
     * @param shift1 First shift
     * @param shift2 Second shift
     * @return Boolean indicating if there's time overlap
     */
    private static Boolean hasTimeOverlap(Shift shift1, Shift shift2) {
        // Two time ranges overlap if:
        // Start1 < End2 AND Start2 < End1
        return shift1.StartTime < shift2.EndTime && shift2.StartTime < shift1.EndTime;
    }
    
    /**
     * @description Check if shifts belong to same service territory
     * @param currentShift Current shift being validated
     * @param existingShift Existing shift to compare against
     * @return Boolean indicating if same service territory
     */
    private static Boolean isSameServiceTerritory(Shift currentShift, Shift existingShift) {
        // Only check for same territory if both have service territory set
        if (currentShift.ServiceTerritoryId != null && existingShift.ServiceTerritoryId != null) {
            return currentShift.ServiceTerritoryId == existingShift.ServiceTerritoryId;
        }
        return false;
    }
    
    /**
     * @description Add overlap error to the current shift
     * @param currentShift Shift to add error to
     * @param conflictingShift Conflicting existing shift
     */
    private static void addOverlapError(Shift currentShift, Shift conflictingShift) {
        String territoryName = conflictingShift.ServiceTerritory?.Name ?? 'Unknown';
        String overlapTime = formatOverlapTime(currentShift, conflictingShift);
        
        String errorMessage = String.format(
            OVERLAP_ERROR_MESSAGE,
            new List<String>{ territoryName, overlapTime }
        );
        
        currentShift.addError(errorMessage);
    }
    
    /**
     * @description Format overlap time for error message
     * @param shift1 First shift
     * @param shift2 Second shift
     * @return Formatted overlap time string
     */
    private static String formatOverlapTime(Shift shift1, Shift shift2) {
        DateTime overlapStart = shift1.StartTime > shift2.StartTime ? shift1.StartTime : shift2.StartTime;
        DateTime overlapEnd = shift1.EndTime < shift2.EndTime ? shift1.EndTime : shift2.EndTime;
        
        return overlapStart.format(DATETIME_FORMAT) + ' - ' + overlapEnd.format(DATETIME_FORMAT);
    }
    
    /**
     * @description Custom exception for shift validation errors
     */
    public class ShiftValidationException extends Exception {}
}

/**
 * @description Trigger on Shift object
 */
trigger ShiftTrigger on Shift (before insert, before update) {
    
    // Handle before insert and update events
    if (Trigger.isBefore && (Trigger.isInsert || Trigger.isUpdate)) {
        ShiftTriggerHandler.validateShiftOverlaps(
            Trigger.new,
            Trigger.isUpdate ? Trigger.oldMap : null
        );
    }
}

/**
 * @description Test class for Shift overlap validation
 */
@isTest
private class ShiftTriggerHandlerTest {
    
    @testSetup
    static void setupTestData() {
        // Create test Service Territory
        ServiceTerritory testTerritory = new ServiceTerritory(
            Name = 'Test Territory',
            IsActive = true,
            OperatingHours = [SELECT Id FROM OperatingHours LIMIT 1].Id
        );
        insert testTerritory;
        
        // Create test Service Resource
        ServiceResource testResource = new ServiceResource(
            Name = 'Test Resource',
            ResourceType = 'T',
            IsActive = true
        );
        insert testResource;
        
        // Create Service Territory Member
        ServiceTerritoryMember stm = new ServiceTerritoryMember(
            ServiceResourceId = testResource.Id,
            ServiceTerritoryId = testTerritory.Id,
            TerritoryType = 'P',
            EffectiveStartDate = Date.today()
        );
        insert stm;
    }
    
    @isTest
    static void testShiftOverlapValidation_SameTerritory_ShouldFail() {
        // Get test data
        ServiceResource resource = [SELECT Id FROM ServiceResource LIMIT 1];
        ServiceTerritory territory = [SELECT Id FROM ServiceTerritory LIMIT 1];
        
        // Create first shift
        Shift firstShift = new Shift(
            ServiceResourceId = resource.Id,
            ServiceTerritoryId = territory.Id,
            StartTime = DateTime.now(),
            EndTime = DateTime.now().addHours(4)
        );
        insert firstShift;
        
        // Try to create overlapping shift
        Shift overlappingShift = new Shift(
            ServiceResourceId = resource.Id,
            ServiceTerritoryId = territory.Id,
            StartTime = DateTime.now().addHours(2),
            EndTime = DateTime.now().addHours(6)
        );
        
        Test.startTest();
        try {
            insert overlappingShift;
            System.assert(false, 'Expected exception was not thrown');
        } catch (DmlException e) {
            System.assert(e.getMessage().contains('already assigned to other ST'));
        }
        Test.stopTest();
    }
    
    @isTest
    static void testShiftOverlapValidation_DifferentTerritory_ShouldPass() {
        // Get test data
        ServiceResource resource = [SELECT Id FROM ServiceResource LIMIT 1];
        ServiceTerritory territory1 = [SELECT Id FROM ServiceTerritory LIMIT 1];
        
        // Create second territory
        ServiceTerritory territory2 = new ServiceTerritory(
            Name = 'Test Territory 2',
            IsActive = true,
            OperatingHours = [SELECT Id FROM OperatingHours LIMIT 1].Id
        );
        insert territory2;
        
        // Create first shift
        Shift firstShift = new Shift(
            ServiceResourceId = resource.Id,
            ServiceTerritoryId = territory1.Id,
            StartTime = DateTime.now(),
            EndTime = DateTime.now().addHours(4)
        );
        insert firstShift;
        
        // Create overlapping shift in different territory
        Shift overlappingShift = new Shift(
            ServiceResourceId = resource.Id,
            ServiceTerritoryId = territory2.Id,
            StartTime = DateTime.now().addHours(2),
            EndTime = DateTime.now().addHours(6)
        );
        
        Test.startTest();
        insert overlappingShift;
        Test.stopTest();
        
        // Should succeed
        System.assertEquals(1, [SELECT COUNT() FROM Shift WHERE Id = :overlappingShift.Id]);
    }
    
    @isTest
    static void testShiftOverlapValidation_NoOverlap_ShouldPass() {
        // Get test data
        ServiceResource resource = [SELECT Id FROM ServiceResource LIMIT 1];
        ServiceTerritory territory = [SELECT Id FROM ServiceTerritory LIMIT 1];
        
        // Create first shift
        Shift firstShift = new Shift(
            ServiceResourceId = resource.Id,
            ServiceTerritoryId = territory.Id,
            StartTime = DateTime.now(),
            EndTime = DateTime.now().addHours(4)
        );
        insert firstShift;
        
        // Create non-overlapping shift
        Shift nonOverlappingShift = new Shift(
            ServiceResourceId = resource.Id,
            ServiceTerritoryId = territory.Id,
            StartTime = DateTime.now().addHours(5),
            EndTime = DateTime.now().addHours(9)
        );
        
        Test.startTest();
        insert nonOverlappingShift;
        Test.stopTest();
        
        // Should succeed
        System.assertEquals(1, [SELECT COUNT() FROM Shift WHERE Id = :nonOverlappingShift.Id]);
    }
    
    @isTest
    static void testShiftUpdate_RemoveOverlap_ShouldPass() {
        // Get test data
        ServiceResource resource = [SELECT Id FROM ServiceResource LIMIT 1];
        ServiceTerritory territory = [SELECT Id FROM ServiceTerritory LIMIT 1];
        
        // Create two overlapping shifts
        List<Shift> shifts = new List<Shift>{
            new Shift(
                ServiceResourceId = resource.Id,
                ServiceTerritoryId = territory.Id,
                StartTime = DateTime.now(),
                EndTime = DateTime.now().addHours(4)
            ),
            new Shift(
                ServiceResourceId = resource.Id,
                ServiceTerritoryId = territory.Id,
                StartTime = DateTime.now().addHours(6),
                EndTime = DateTime.now().addHours(10)
            )
        };
        insert shifts;
        
        // Update second shift to create overlap
        shifts[1].StartTime = DateTime.now().addHours(2);
        
        Test.startTest();
        try {
            update shifts[1];
            System.assert(false, 'Expected exception was not thrown');
        } catch (DmlException e) {
            System.assert(e.getMessage().contains('already assigned to other ST'));
        }
        Test.stopTest();
    }
}
